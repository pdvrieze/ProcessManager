/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.09.24 at 08:12:58 PM CEST
//


package org.w3.soapEnvelope

import kotlinx.serialization.*
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.encoding.*
import net.devrieze.util.security.SimplePrincipal
import nl.adaptivity.util.multiplatform.URI
import nl.adaptivity.util.multiplatform.toUri
import nl.adaptivity.util.net.devrieze.serializers.URISerializer
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.core.impl.multiplatform.name
import nl.adaptivity.xmlutil.serialization.XML
import nl.adaptivity.xmlutil.serialization.XmlSerialName
import nl.adaptivity.xmlutil.util.CompactFragment
import nl.adaptivity.xmlutil.util.CompactFragmentSerializer


/**
 * Elements replacing the wildcard MUST be namespace qualified, but can be in
 * the targetNamespace
 *
 *
 * Java class for Header complex type.
 *
 *
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * ```
 * <complexType name="Header">
 * <complexContent>
 * <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 * <sequence>
 * <any processContents='lax' maxOccurs="unbounded" minOccurs="0"/>
 * </sequence>
 * <anyAttribute processContents='lax' namespace='##other'/>
 * </restriction>
 * </complexContent>
 * </complexType>
 *
 */
@Serializable(Header.Serializer::class)
@XmlSerialName(Header.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX)
class Header(
    val blocks: List<Block<Any>> = emptyList(),
    val encodingStyle: URI? = null,
    val otherAttributes: Map<QName, String> = emptyMap()
) {
    @Transient
    var principal: SimplePrincipal? = null
        private set

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false

        other as Header

        if (blocks != other.blocks) return false
        if (encodingStyle != other.encodingStyle) return false
        if (otherAttributes != other.otherAttributes) return false

        return true
    }

    override fun hashCode(): Int {
        var result = blocks.hashCode()
        result = 31 * result + (encodingStyle?.hashCode() ?: 0)
        result = 31 * result + otherAttributes.hashCode()
        return result
    }

    sealed class Block<out T: Any> {
        abstract fun get(): T

        abstract internal fun toCompactFragment(): CompactFragment
    }

    class SupportedBlock<T: Any>(val data: T, val serializer: KSerializer<T>): Block<T>() {
        override fun get(): T = data

        override fun toCompactFragment(): CompactFragment {
            val s: SerializationStrategy<T> = serializer
            return CompactFragment(XML.encodeToString<T>(s, value = data))
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other == null || this::class != other::class) return false

            other as SupportedBlock<*>

            return data == other.data
        }

        override fun hashCode(): Int {
            return data.hashCode()
        }

        companion object {
            inline operator fun <reified T:Any> invoke(data: T): SupportedBlock<T> {
                val serializer = kotlinx.serialization.serializer<T>()
                return SupportedBlock(data, serializer)
            }
        }
    }

    class UnsupportedBlock(val xml: CompactFragment): Block<CompactFragment>() {
        override fun get(): CompactFragment = xml
        override fun toCompactFragment(): CompactFragment = xml

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other == null || this::class != other::class) return false

            other as UnsupportedBlock

            return xml == other.xml
        }

        override fun hashCode(): Int {
            return xml.hashCode()
        }
    }

    companion object Serializer: XmlSerializer<Header> {
        private val blockSerializer = ListSerializer(CompactFragmentSerializer)

        @OptIn(ExperimentalSerializationApi::class, nl.adaptivity.xmlutil.XmlUtilInternal::class)
        override val descriptor: SerialDescriptor = buildClassSerialDescriptor(Header::class.name) {
            annotations = SoapSerialObjects.headerAnnotations
            element("encodingStyle", URISerializer.descriptor, SoapSerialObjects.encodingStyleAnnotations, true)
            element("otherAttributes", SoapSerialObjects.attrsSerializer.descriptor, isOptional = true)
            element("blocks", blockSerializer.descriptor)
        }

        override fun deserialize(decoder: Decoder): Header {
            var encodingStyle: URI? = null
            var otherAttributes: Map<QName, String> = emptyMap()
            lateinit var blocks: List<Block<Any>>
            decoder.decodeStructure(descriptor) {
                // TODO handle "supported header elements"
                var idx: Int
                while (decodeElementIndex(descriptor).also { idx = it } != CompositeDecoder.DECODE_DONE) {
                    when (idx) {
                        0 -> encodingStyle = decodeSerializableElement(descriptor, idx, URISerializer, encodingStyle)
                        1 -> otherAttributes = decodeSerializableElement(descriptor, idx, SoapSerialObjects.attrsSerializer, otherAttributes)
                        2 -> blocks = decodeSerializableElement(descriptor, idx, ListSerializer(CompactFragmentSerializer)).map { UnsupportedBlock(it) }
                    }
                }
            }
            return Header(blocks, encodingStyle, otherAttributes)
        }

        override fun deserializeXML(
            decoder: Decoder,
            input: XmlReader,
            previousValue: Header?,
            isValueChild: Boolean
        ): Header {
            var encodingStyle: URI? = null
            var otherAttributes: Map<QName, String> = emptyMap()
            lateinit var blocks: List<Block<Any>>
            decoder.decodeStructure(descriptor) {
                otherAttributes = input.attributes.filter {
                    when {
                        it.prefix == XMLConstants.XMLNS_ATTRIBUTE ||
                            (it.prefix == "" && it.localName == XMLConstants.XMLNS_ATTRIBUTE) -> false

                        it.namespaceUri != Envelope.NAMESPACE -> true
                        it.localName == "encodingStyle" -> {
                            encodingStyle = it.value.toUri(); false
                        }

                        else -> true
                    }
                }.associate { QName(it.namespaceUri, it.localName, it.prefix) to it.value }

                val myBlocks = mutableListOf<Block<Any>>()
                while (input.nextTag() != EventType.END_ELEMENT) {
                    // TODO handle "supported header elements"
                    val cf = input.elementContentToFragment().let {
                        it as? CompactFragment ?: CompactFragment(it)
                    }
                    myBlocks.add(UnsupportedBlock(cf))
                }
                blocks = myBlocks
            }
            return Header(blocks, encodingStyle, otherAttributes)
        }

        override fun serialize(encoder: Encoder, value: Header) {
            encoder.encodeStructure(descriptor) {
                value.encodingStyle?.also { style ->
                    encodeSerializableElement(descriptor, 0, URISerializer, style)
                }
                if (value.otherAttributes.isNotEmpty()) {
                    encodeSerializableElement(descriptor, 1, SoapSerialObjects.attrsSerializer, value.otherAttributes)
                }
                // TODO optimize this for xml
                val blocks = value.blocks.map(Block<Any>::toCompactFragment)
                encodeSerializableElement(descriptor, 2, blockSerializer, blocks)
            }
        }

        override fun serializeXML(encoder: Encoder, output: XmlWriter, value: Header, isValueChild: Boolean) {
            serialize(encoder, value)
        }

        const val ELEMENTLOCALNAME = "Header"
    }

}
