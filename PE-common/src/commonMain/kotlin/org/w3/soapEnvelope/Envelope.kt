/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.09.24 at 08:12:58 PM CEST
//


package org.w3.soapEnvelope

import kotlinx.serialization.EncodeDefault
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.*
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.serialization.*
import nl.adaptivity.xmlutil.util.ICompactFragment

/**
 *
 *
 * Java class for Envelope complex type.
 *
 *
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * ```
 * <complexType name="Envelope">
 * <complexContent>
 * <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 * <sequence>
 * <element ref="{http://www.w3.org/2003/05/soap-envelope}Header" minOccurs="0"/>
 * <element ref="{http://www.w3.org/2003/05/soap-envelope}Body"/>
 * </sequence>
 * <anyAttribute processContents='lax' namespace='##other'/>
 * </restriction>
 * </complexContent>
 * </complexType>
 * ```
 *
 * @property otherAttributes A map that contains attributes that aren't bound to any typed property
 *                   on this class.
 *                   the map is keyed by the name of the attribute and the value is the string value
 *                   of the attribute. the map returned by this method is live, and you can add new
 *                   attribute by updating the map directly. Because of this design, there's no
 *                   setter.
 */
@Serializable/*(Envelope.Serializer::class)*/
@XmlSerialName(Envelope.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX)
class Envelope<T : Any>(
    val body: Body<T>,
    @XmlBefore("body")
    @EncodeDefault(EncodeDefault.Mode.NEVER)
    val header: Header = Header(),
    @XmlOtherAttributes
    val otherAttributes: Map<SerializableQName, String> = emptyMap(),
) {

    constructor(content: T) : this(Body<T>(content))

    companion object {

        const val NAMESPACE = "http://www.w3.org/2003/05/soap-envelope"

        const val ELEMENTLOCALNAME = "Envelope"

        const val PREFIX = "soap"

        val ELEMENTNAME = QName(NAMESPACE, ELEMENTLOCALNAME, PREFIX)

        const val MIMETYPE = "application/soap+xml"

        @kotlin.jvm.JvmStatic
        fun deserialize(reader: XmlReader): Envelope<out ICompactFragment> {
            return XML { indent=2; autoPolymorphic = true }.decodeFromReader(serializer(CompactFragmentSerializer), reader)
        }

    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false

        other as Envelope<*>

        if (body != other.body) return false
        if (header != other.header) return false
        if (otherAttributes != other.otherAttributes) return false

        return true
    }

    override fun hashCode(): Int {
        var result = body.hashCode()
        result = 31 * result + header.hashCode()
        result = 31 * result + otherAttributes.hashCode()
        return result
    }

}

internal object SoapSerialObjects {
    @Serializable
    private class AnnotationHelper(
        @XmlSerialName(Envelope.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX)
        val envelope: String,
        @XmlSerialName(Header.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX)
        val header: String,
        @XmlSerialName("Body", Envelope.NAMESPACE, Envelope.PREFIX)
        val body: String,
        @XmlSerialName("encodingStyle", Envelope.NAMESPACE, Envelope.PREFIX)
        val encodingStyle: String,
        @XmlValue(true)
        val value: String,
    )

    val envelopeAnnotations = listOf(XmlSerialName(Envelope.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val headerAnnotations = listOf(XmlSerialName(Header.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val bodyAnnotations = listOf(XmlSerialName("Body", Envelope.NAMESPACE, Envelope.PREFIX))

    val encodingStyleAnnotations = listOf(XmlSerialName("encodingStyle", Envelope.NAMESPACE, Envelope.PREFIX))

    val valueAnnotations = listOf(XmlValue(true))

    object attrsSerializer : KSerializer<Map<QName, String>> {
        private val default = MapSerializer(QNameSerializer, String.serializer())

        override val descriptor: SerialDescriptor = SerialDescriptor("attrsSerializer", default.descriptor)

        override fun deserialize(decoder: Decoder): Map<QName, String> {
            return if (decoder is XML.XmlInput) {
                decoder.input.attributes
                    .asSequence()
                    .filter { !(it.prefix == "xmlns" || (it.prefix == "" && it.localName == "xmlns")) }
                    .associate { QName(it.namespaceUri, it.localName, it.prefix) to it.value }
                    .toMap()
            } else {
                default.deserialize(decoder)
            }
        }

        override fun serialize(encoder: Encoder, value: Map<QName, String>) {
            if (encoder is XML.XmlOutput) {
                val out = encoder.target
                for ((name, aValue) in value) {
                    out.attribute(name.namespaceURI, name.localPart, name.prefix, aValue)
                }
            } else {
                default.serialize(encoder, value)
            }
        }
    }

}
