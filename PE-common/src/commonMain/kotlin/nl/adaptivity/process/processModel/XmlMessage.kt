/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel

import kotlinx.serialization.*
import kotlinx.serialization.internal.SerialClassDescImpl
import nl.adaptivity.messaging.EndpointDescriptor
import nl.adaptivity.messaging.EndpointDescriptorImpl
import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.util.multiplatform.JvmName
import nl.adaptivity.util.multiplatform.name
import nl.adaptivity.util.multiplatform.toUri
import nl.adaptivity.xml.localPart
import nl.adaptivity.xmlutil.*
import nl.adaptivity.serialutil.*
import nl.adaptivity.xmlutil.serialization.XmlSerialName
import nl.adaptivity.serialutil.encodeNullableStringElement
import nl.adaptivity.serialutil.readNullableString
import nl.adaptivity.xmlutil.util.CompactFragment
import nl.adaptivity.xmlutil.util.ExtXmlDeserializable
import nl.adaptivity.xmlutil.util.ICompactFragment
import nl.adaptivity.xml.QName as DescQName
import nl.adaptivity.xmlutil.QName as XmlQName


/**
 *
 *
 * Java class for Message complex type.
 *
 *
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * ```
 * <complexType name="Message">
 * <complexContent>
 * <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 * <sequence>
 * <any processContents='lax'/>
 * </sequence>
 * <attribute name="serviceNS" type="{http://www.w3.org/2001/XMLSchema}string" />
 * <attribute name="endpoint" type="{http://www.w3.org/2001/XMLSchema}string" />
 * <attribute name="operation" type="{http://www.w3.org/2001/XMLSchema}string" />
 * <attribute name="serviceName" type="{http://www.w3.org/2001/XMLSchema}NCName" />
 * <attribute name="url" type="{http://www.w3.org/2001/XMLSchema}string" />
 * <attribute name="method" type="{http://www.w3.org/2001/XMLSchema}string" />
 * </restriction>
 * </complexContent>
 * </complexType>
 * ```
 */
@XmlDeserializer(XmlMessage.Factory::class)
@Serializable
@XmlSerialName(XmlMessage.ELEMENTLOCALNAME, Engine.NAMESPACE, Engine.NSPREFIX)
class XmlMessage : XMLContainer, IXmlMessage, ExtXmlDeserializable {

    @Transient
    override var service: DescQName?

    override var endpoint: String?
    override var operation: String?
    override var url: String?
    override var method: String?

    @Transient
    override val endpointDescriptor: EndpointDescriptor?
        get() = EndpointDescriptorImpl(service, endpoint, this.url?.toUri())

    private var type: String? = contentType

    @Transient
    override val contentType: String
        get() = type ?: "application/soap+xml"

    @Transient
    override val elementName: XmlQName
        get() = ELEMENTNAME

    @Serializable
    override var serviceName: String?
        get() = service?.localPart
        set(name) {
            service = name?.let { DescQName(service?.getNamespaceURI() ?: "", it) }
        }

    override var serviceNS: String?
        get() = service?.getNamespaceURI()
        set(namespace) {
            this.service = namespace?.let { DescQName(it, service?.getLocalPart() ?: "xx") }
        }

    override var namespaces: SimpleNamespaceContext
        get() = super.namespaces
        set(value) {
            super.namespaces = value
        }

    override var content: CharArray
        get() = super.content
        set(value) {
            super.content = value
        }

    @Transient
    override val messageBody: ICompactFragment
        get() = CompactFragment(namespaces, content)

    class Factory : XmlDeserializerFactory<XmlMessage> {

        override fun deserialize(reader: XmlReader): XmlMessage {
            return XmlMessage.deserialize(reader)
        }
    }

    constructor() : this(service = null) { /* default constructor */
    }


    constructor(service: DescQName? = null,
                endpoint: String? = null,
                operation: String? = null,
                url: String? = null,
                method: String? = null,
                contentType: String? = null,
                messageBody: ICompactFragment? = null) {
        this.service = service
        this.endpoint = endpoint
        this.operation = operation
        this.url = url
        this.method = method
        this.type = contentType
        messageBody?.let {
            namespaces = SimpleNamespaceContext(it.namespaces)
            content = it.content
        }
    }

    override fun serializeAttributes(out: XmlWriter) {
        super.serializeAttributes(out)
        out.writeAttribute("type", contentType)
        out.writeAttribute("serviceNS", serviceNS)
        out.writeAttribute("serviceName", serviceName)
        out.writeAttribute("endpoint", endpoint)
        out.writeAttribute("operation", operation)
        out.writeAttribute("url", url)
        out.writeAttribute("method", method)
    }

    override fun onBeforeDeserializeChildren(reader: XmlReader) {
        super<XMLContainer>.onBeforeDeserializeChildren(reader)
    }

    override fun deserializeAttribute(attributeNamespace: String?,
                                      attributeLocalName: String,
                                      attributeValue: String): Boolean {
        if (XMLConstants.NULL_NS_URI == attributeNamespace) {
            when (attributeLocalName) {
                "endpoint"    -> {
                    endpoint = attributeValue
                    return true
                }
                "operation"   -> {
                    operation = attributeValue
                    return true
                }
                "url"         -> {
                    url = attributeValue
                    return true
                }
                "method"      -> {
                    method = attributeValue
                    return true
                }
                "type"        -> {
                    type = attributeValue
                    return true
                }
                "serviceNS"   -> {
                    serviceNS = attributeValue
                    return true
                }
                "serviceName" -> {
                    serviceName = attributeValue
                    return true
                }
            }
        }
        return false
    }

    override fun serializeStartElement(out: XmlWriter) {
        out.smartStartTag(elementName)
    }

    override fun serializeEndElement(out: XmlWriter) {
        out.endTag(elementName)
    }

    override fun setType(type: String) {
        this.type = type
    }

    override fun toString(): String {
        return XmlStreaming.toString(this)
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false

        other as XmlMessage

        if (service != other.service) return false
        if (endpoint != other.endpoint) return false
        if (operation != other.operation) return false
        if (url != other.url) return false
        if (method != other.method) return false
        if (type != other.type) return false

        return true
    }

    override fun hashCode(): Int {
        var result = service?.hashCode() ?: 0
        result = 31 * result + (endpoint?.hashCode() ?: 0)
        result = 31 * result + (operation?.hashCode() ?: 0)
        result = 31 * result + (url?.hashCode() ?: 0)
        result = 31 * result + (method?.hashCode() ?: 0)
        result = 31 * result + (type?.hashCode() ?: 0)
        return result
    }

    @Serializer(forClass = XmlMessage::class)
    companion object : XmlContainerSerializer<XmlMessage>() {

        const val ELEMENTLOCALNAME = "message"

        val ELEMENTNAME = XmlQName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX)


        @JvmName("fromNullable")
        fun from(message: IXmlMessage?) = when (message) {
            null -> null
            else -> from(message)
        }

        fun from(message: IXmlMessage): XmlMessage {
            return message as? XmlMessage ?: XmlMessage(message.service,
                                                        message.endpoint,
                                                        message.operation,
                                                        message.url,
                                                        message.method,
                                                        message.contentType,
                                                        message.messageBody)
        }

        fun deserialize(reader: XmlReader): XmlMessage {
            return XmlMessage().deserializeHelper(reader)
        }

        override fun deserialize(decoder: Decoder): XmlMessage {
            val data = XmlMessageData(this).apply { deserialize(descriptor, decoder, XmlMessage.Companion) }

            return XmlMessage(data.service, data.endpoint, data.operation, data.url, data.method, data.contentType,
                              data.fragment)
        }

        override val descriptor: SerialDescriptor = XmlMessageData.serializer().descriptor


        override fun serialize(encoder: Encoder, obj: XmlMessage) {
            super.serialize(descriptor, encoder, obj)
        }

        override fun writeAdditionalValues(encoder: CompositeEncoder, desc: SerialDescriptor, data: XmlMessage) {
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("type"), data.contentType)
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("serviceNS"), data.serviceNS)
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("serviceName"), data.serviceName)
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("endpoint"), data.endpoint)
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("operation"), data.operation)
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("url"), data.url)
            encoder.encodeNullableStringElement(desc, desc.getElementIndex("method"), data.method)
            super.writeAdditionalValues(encoder, desc, data)
        }

        @Serializable
        @XmlSerialName(XmlMessage.ELEMENTLOCALNAME, Engine.NAMESPACE, Engine.NSPREFIX)
        private class XmlMessageData : XmlContainerSerializer.ContainerData<XmlMessage> {
            constructor(owner: XmlMessage.Companion) : super()

            var serviceName: String? = null
            var serviceNS: String? = null
            var endpoint: String? = null
            var operation: String? = null
            var url: String? = null
            var method: String? = null
            @SerialName("type")
            var contentType: String? = null

            val service: DescQName? get() = serviceName?.let { DescQName(serviceNS ?: "", it) }

            override fun handleAttribute(attributeLocalName: String, attributeValue: String) {
                return when (attributeLocalName) {
                    "serviceName" -> serviceName = attributeValue
                    "serviceNS"   -> serviceNS = attributeValue
                    "endpoint"    -> endpoint = attributeValue
                    "operation"   -> operation = attributeValue
                    "url"         -> url = attributeValue
                    "method"      -> method = attributeValue
                    "type"        -> contentType = attributeValue

                    else          -> super.handleAttribute(attributeLocalName, attributeValue)
                }
            }

            override fun readAdditionalChild(desc: SerialDescriptor, decoder: CompositeDecoder, index: Int) {
                val name = desc.getElementName(index)
                val value = decoder.readNullableString(desc, index)
                if (value != null) {
                    handleAttribute(name, value)
                }
            }
        }
    }

}

