/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.process.util.Identified
import nl.adaptivity.process.util.PrefixCompactFragmentSerializer
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.serialization.XML
import nl.adaptivity.xmlutil.serialization.XmlSerialName
import nl.adaptivity.xmlutil.serialization.XmlValue
import nl.adaptivity.xmlutil.util.CompactFragment

@Serializable(XmlDefineType.Serializer::class)
class XmlDefineType : XPathHolder, IXmlDefineType {

    @ProcessModelDSL
    class Builder {

        var name: String? = null
        var path: String? = null
        var content: CharArray
        var nsContext: MutableList<Namespace>

        internal constructor() {
            name = null
            path = null
            content = CharArray(0)
            nsContext = ArrayList<Namespace>()
        }

        internal constructor(orig: IXmlResultType) {
            name = orig.getName()
            path = orig.getPath()
            content = orig.content?.copyOf() ?: CharArray(0)
            nsContext = ArrayList<Namespace>()
            val origContext = orig.originalNSContext
            for (ns in origContext) {
                nsContext.add(ns)
            }
        }

        fun build(): XmlResultType {
            @OptIn(XmlUtilInternal::class)
            return XmlResultType(name, path, content, SimpleNamespaceContext(nsContext))
        }
    }

    @SerialName("refnode")
    private var _refNode: String? = null

    @SerialName("refname")
    private var _refName: String? = null

    constructor() {}

    @OptIn(XmlUtilInternal::class)
    constructor(
        name: String?,
        refNode: String?,
        refName: String? = null,
        path: String? = null,
        content: CharArray? = null,
        originalNSContext: IterableNamespaceContext = SimpleNamespaceContext()
    ) : super(
        name, path, content,
        originalNSContext
    ) {
        this._refNode = refNode
        this._refName = refName
    }


    @OptIn(XmlUtilInternal::class)
    constructor(
        name: String?,
        refNode: Identified,
        refName: String? = null,
        path: String? = null,
        content: CharArray? = null,
        originalNSContext: IterableNamespaceContext = SimpleNamespaceContext()
    ) : this(name, refNode.id, refName, path, content, originalNSContext)

    override fun copy(
        name: String,
        refNode: String?,
        refName: String?,
        path: String?,
        content: CharArray?,
        nsContext: IterableNamespaceContext
    ): XmlDefineType {
        return XmlDefineType(name, refNode, refName, path, content, nsContext)
    }

    override fun serialize(out: XmlWriter) {
        XML { autoPolymorphic = true }.encodeToWriter(out, serializer(), this)
    }

    override fun getRefNode(): String? {
        return _refNode
    }

    /* (non-Javadoc)
     * @see nl.adaptivity.process.processModel.IXmlDefineType#setRefNode(String)
     */
    override fun setRefNode(value: String?) {
        this._refNode = value
    }

    /* (non-Javadoc)
     * @see nl.adaptivity.process.processModel.XmlImportType#getName()
     */
    override fun getRefName(): String? {
        return _refName
    }

    /* (non-Javadoc)
     * @see nl.adaptivity.process.processModel.XmlImportType#setName(java.lang.String)
     */
    override fun setRefName(value: String?) {
        this._refName = value
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false
        if (!super.equals(other)) return false

        other as XmlDefineType

        if (_refNode != other._refNode) return false
        if (_refName != other._refName) return false

        return true
    }

    override fun hashCode(): Int {
        var result = super.hashCode()
        result = 31 * result + (_refNode?.hashCode() ?: 0)
        result = 31 * result + (_refName?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String {
        return "XmlDefineType(content=$contentString, namespaces=(${originalNSContext.joinToString()}), name=$name, path=${getPath()}, refNode=$_refNode, refName=$_refName)"
    }

    @Serializable
    @XmlSerialName(value = ELEMENTLOCALNAME, namespace = Engine.NAMESPACE, prefix = Engine.NSPREFIX)
    private class SerialDelegate private constructor(
        @SerialName("name") val name: String?,
        @SerialName("refnode") val refNode: String? = null,
        @SerialName("refname") val refName: String? = null,
        @SerialName("xpath") val _xpath: String? = null,
        @SerialName("path") val _path: String? = null,
        @XmlValue override val content: @Serializable(PrefixCompactFragmentSerializer::class) CompactFragment,
    ): XPathHolderSerializer.SerialDelegateBase {
        override val xpath: String? get() = _xpath ?: _path

        constructor(
            name: String?,
            refNode: String? = null,
            refName: String? = null,
            xpath: String? = null,
            content: CompactFragment
        ): this(name, refNode, refName, xpath, null, content)
    }

    private class Serializer : XPathHolderSerializer<XmlDefineType, SerialDelegate>(SerialDelegate.serializer()) {

        @OptIn(ExperimentalSerializationApi::class)
        override val descriptor = SerialDescriptor(
            "nl.adaptivity.process.processModel.XmlDefineType",
            delegateSerializer.descriptor
        )

        override fun deserialize(decoder: Decoder): XmlDefineType {
            val (data, extNamespaces) = deserializeCommon(decoder)

            return XmlDefineType(data.name, data.refNode, data.refName, data.xpath, data.content.content, extNamespaces)
        }

        override fun serialize(encoder: Encoder, value: XmlDefineType) {
            val delegate = SerialDelegate(value.name, value.refNode, value.refName, value.getPath(), value.fragment)
            delegateSerializer.serialize(encoder, delegate)
        }

    }

    companion object{

        const val ELEMENTLOCALNAME = "define"


        @Deprecated(
            "Use normal factory method",
            ReplaceWith("XmlDefineType(export)", "nl.adaptivity.process.processModel.XmlDefineType")
        )
        @kotlin.jvm.JvmStatic
        operator fun get(export: IXmlDefineType) = XmlDefineType(export)


    }
}

fun XmlDefineType(export: IXmlDefineType): XmlDefineType {
    if (export is XmlDefineType) {
        return export
    }
    @OptIn(XmlUtilInternal::class)
    return XmlDefineType(
        name = export.getName(),
        refNode = export.getRefNode(),
        refName = export.getRefName(),
        path = export.getPath(),
        content = export.content,
        originalNSContext = export.originalNSContext
    )
}
