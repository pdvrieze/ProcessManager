/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the 
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel

import kotlinx.serialization.*
import kotlinx.serialization.internal.StringSerializer
import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.serialization.XmlSerialName
import nl.adaptivity.xmlutil.serialization.simpleSerialClassDesc

@XmlDeserializer(XmlResultType.Factory::class)
@Serializable
@XmlSerialName(value = XmlResultType.ELEMENTLOCALNAME, namespace = Engine.NAMESPACE, prefix = Engine.NSPREFIX)
class XmlResultType : XPathHolder, IXmlResultType, XmlSerializable {

    constructor(name: String?, path: String?, content: CharArray?, originalNSContext: Iterable<Namespace>?) : super(
        name, path, content, originalNSContext ?: emptyList())

    @Deprecated("Use one of the parameterized constructors")
    constructor() : this(null, null, null, null)

    class Factory : XmlDeserializerFactory<XmlResultType> {

        override fun deserialize(reader: XmlReader): XmlResultType {
            return Companion.deserialize(reader)
        }

    }

    @ProcessModelDSL
    class Builder {

        var name: String?
        var path: String?
        var content: CharArray?
        val nsContext: MutableList<Namespace>

        constructor() {
            name = null
            path = null
            content = CharArray(0)
            nsContext = mutableListOf<Namespace>()
        }

        constructor(orig: IXmlResultType) {
            name = orig.getName()
            path = orig.getPath()
            content = orig.content?.copyOf()
            nsContext = orig.originalNSContext.toMutableList()
        }

        fun build(): XmlResultType {
            return XmlResultType(name, path, content, nsContext)
        }

    }

    override fun serializeStartElement(out: XmlWriter) {
        out.smartStartTag(ELEMENTNAME)
    }

    override fun serializeEndElement(out: XmlWriter) {
        out.endTag(ELEMENTNAME)
    }

    @Transient
    override val elementName: QName
        get() = ELEMENTNAME

    @Serializer(forClass = XmlResultType::class)
    companion object : XPathHolderSerializer<XmlResultType>(), KSerializer<XmlResultType> {
        override val descriptor = simpleSerialClassDesc<XmlResultType>(XmlResultTypeAnnotationHelper.descriptor.getEntityAnnotations(),
                                                                       "name" to StringSerializer,
                                                                       "xpath" to StringSerializer,
                                                                       "namespaces" to Namespace.list,
                                                                       "content" to StringSerializer)

        @kotlin.jvm.JvmStatic
        fun deserialize(reader: XmlReader): XmlResultType {
            return deserialize(reader, XmlResultType())
        }

        const val ELEMENTLOCALNAME = "result"
        private val ELEMENTNAME = QName(Engine.NAMESPACE,
                                        ELEMENTLOCALNAME, Engine.NSPREFIX)

        @Deprecated("Use normal factory method",
                    ReplaceWith("XmlResultType(import)", "nl.adaptivity.process.processModel.XmlResultType"))
        operator fun get(import: IXmlResultType) = XmlResultType(import)

        override fun deserialize(decoder: Decoder): XmlResultType {
            val data = PathHolderData(this)
            data.deserialize(descriptor, decoder)
            return XmlResultType(data.name, data.path, data.content, data.namespaces)
        }

        override fun patch(decoder: Decoder, old: XmlResultType): XmlResultType {
            with(PathHolderData(this)) {
                name = old.name
                path = old.path
                content = old.content
                namespaces = old.namespaces
                deserialize(descriptor, decoder)

                return XmlResultType(name, path, content, namespaces)
            }
        }

        override fun serialize(encoder: Encoder, obj: XmlResultType) {
            serialize(descriptor, encoder, obj)
        }
    }

}

fun XmlResultType(import: IXmlResultType): XmlResultType {
    if (import is XmlResultType) {
        return import
    }
    val originalNSContext: Iterable<Namespace> = import.originalNSContext
    return XmlResultType(import.getName(), import.getPath(), content = null,
                         originalNSContext = originalNSContext)
}

/** Dummy serializer that is just used to get the annotations on the type. */
@Serializer(XmlResultType::class)
private object XmlResultTypeAnnotationHelper {}
