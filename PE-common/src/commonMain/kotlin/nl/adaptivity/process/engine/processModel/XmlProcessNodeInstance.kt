/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2014.08.06 at 08:14:28 PM BST
//


package nl.adaptivity.process.engine.processModel

import net.devrieze.util.Handle
import net.devrieze.util.handle
import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.process.engine.ProcessData
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.serialization.XML
import nl.adaptivity.xmlutil.util.ICompactFragment
import nl.adaptivity.xmlutil.xmlserializable.SimpleXmlDeserializable
import nl.adaptivity.xmlutil.xmlserializable.XmlDeserializer
import nl.adaptivity.xmlutil.xmlserializable.deserializeHelper

class XmlProcessNodeInstance {

    constructor()

    constructor(
        nodeId: String,
        predecessors: Iterable<Handle<XmlProcessNodeInstance>>,
        processInstance: Long,
        handle: Handle<XmlProcessNodeInstance>,
        state: NodeInstanceState,
        results: Iterable<ProcessData>,
        body: ICompactFragment?
               ) {
        this.nodeId = nodeId
        this._predecessors.addAll(predecessors)
        this.processInstance = processInstance
        this.handle = handle.handleValue
        this.state = state
        this.results.addAll(results)
        this.body = body
    }

    private val _predecessors = mutableListOf<Handle<XmlProcessNodeInstance>>()

    /**
     * Gets the value of the predecessor property.
     */
    val predecessors: List<Handle<XmlProcessNodeInstance>>
        get() = _predecessors

    var body: ICompactFragment? = null

    var handle = -1L

    var entryNo = 0

    var state: NodeInstanceState? = null

    var stateXml: String?
        get() = state?.name
        set(value) {
            state = value?.let { NodeInstanceState.valueOf(it) }
        }

    var processInstance: Long = -1

    var nodeId: String? = null

    var results: MutableList<ProcessData> = mutableListOf()

    var xmlProcessinstance: Long?
        get() = if (processInstance == -1L) null else processInstance
        set(value) {
            this.processInstance = value ?: -1L
        }

    companion object {

        const val ELEMENTLOCALNAME = "nodeInstance"
        val ELEMENTNAME = QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX)
        const val PREDECESSOR_LOCALNAME = "predecessor"
        val PREDECESSOR_ELEMENTNAME = QName(Engine.NAMESPACE, PREDECESSOR_LOCALNAME, Engine.NSPREFIX)
        const val RESULT_LOCALNAME = "result"
        val RESULT_ELEMENTNAME = QName(Engine.NAMESPACE, RESULT_LOCALNAME, Engine.NSPREFIX)
        const private val BODY_LOCALNAME = "body"
        internal val BODY_ELEMENTNAME = QName(Engine.NAMESPACE, BODY_LOCALNAME, Engine.NSPREFIX)

        fun deserialize(reader: XmlReader): XmlProcessNodeInstance {
            return XML.decodeFromReader(reader)
        }
    }


}
